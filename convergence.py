import math

def newtonIteration(p0, tol, N0):
    i = 0
    terms = []

    while (i < N0):

        p = p0 - f(p0)/f1(p0)
        terms.append(p0)

        if abs(p-p0) < tol:
            terms.append(p)
            return terms
            break

        i += 1
        p0 = p
    
    return None

def finalNewtonIteration(p0, tol, N0):
    i = 0
    terms = []

    while (i < N0):

        p = p0 - (f(p0)*f1(p0))/((f1(p0))**2 - f(p0)*f2(p0))
        terms.append(p0)

        if abs(p-p0) < tol:
            terms.append(p)
            return terms
            break

        i += 1
        p0 = p
    
    return None

def f(x):
    return math.e**x - x - 1

def f1(x):
    return math.e**x - 1

def f2(x):
    return math.e**x

print("f(x) at x = 0:", f(0))
print("f'(x) at x = 0:", f1(0))
print("f''(x) at x = 0:", f2(0))

print("Hence, f has a zero of multiplicity 2 at x = 0.")

first = newtonIteration(1, 1e-3, 11)
pi = math.log(first[-1]/first[-2])/math.log(first[-2]/first[-3])

print("The order of convergence is approximately", pi)

print("The sequence converges linearly to 0, as can also be seen from the terms generated by the Newton's Method:")

for index, item in enumerate(first):
    print("Term No.", index+1, ":", item)

print("Newton's method does not converge quadratically for this choice of f(x) as f'(0) was equal to 0.")

print("Hence, we modify the Newton Method to use f(x)/f'(x) as a whole instead of f(x) when iterating through g(x) = x - f(x)/f'(x).")
print("Now, the terms generated by the Modified Newton's Method are:")

second = finalNewtonIteration(1, 1e-4, 4)
phi = math.log(second[-1]/second[-2])/math.log(second[-2]/second[-3])

for index, item in enumerate(second):
    print("Term No.", index+1, ":", item)

print("The order of convergence of the Modified Newton's Method is approximately", phi)